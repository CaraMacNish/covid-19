{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Case Study \n",
    "# Covid-19 in Australia"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "New concepts\n",
    "\n",
    "* Introducing time-series data\n",
    "* Using GroupBy to group data\n",
    "* Growth rates\n",
    "* Curve fitting\n",
    "\n",
    "Reinforced concepts\n",
    "\n",
    "* File IO\n",
    "* File formats\n",
    "* Data/object types\n",
    "* Data selection and manipulation with pandas (and friends)\n",
    "* Using apply and lambda functions\n",
    "* Using list comprehensions\n",
    "* Plotting data with pyplot (and pandas directly)\n",
    "* Using subplots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Finding a Reliable Covid-19 Data Source\n",
    "\n",
    "There are many possible sources of data (of varying quality and veracity). We always look for a trusted source of data, such as the World Health Organisation (WHO).\n",
    "\n",
    "Academics from John Hopkins University have done a great job of collecting data from reliable sources (including WHO) and making it publicly available as a \"[dashboard](https://www.arcgis.com/apps/opsdashboard/index.html#/bda7594740fd40299423467b48e9ecf6)\". Note that the data sources (as well as a short article in the Journal [_Lancet_](https://www.sciencedirect.com/science/article/pii/S1473309920301201?via%3Dihub) are provided at the bottom of the page.\n",
    "\n",
    "The authors also provide a link to the data sources on [Github](https://github.com/CSSEGISandData/COVID-19). The data is shared and downloadable.\n",
    "\n",
    "(This is an example of best practice in sharing and documenting data for the common good!)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### A first look at the data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The package downloaded from Github contains the following files:\n",
    "\n",
    "```\n",
    "datapackage.json\n",
    "process.py\n",
    "README.md\n",
    "time-series-19-covid-combined.csv\n",
    "```\n",
    "\n",
    "> _Q: What types are they and what do you anticipate they will contain?_\n",
    "\n",
    "Lets look at them in a terminal and see if we're right &rarr;\n",
    "\n",
    "Jupyter Lab can handle all of these file types, so lets take a closer look using Jupyter Lab &rarr;\n",
    "\n",
    "Lets use some of our skills learnt so far to read in the data, inspect it more closely, and extract the data we're interested in."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Extraction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "#%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Date</th>\n",
       "      <th>Country/Region</th>\n",
       "      <th>Province/State</th>\n",
       "      <th>Lat</th>\n",
       "      <th>Long</th>\n",
       "      <th>Confirmed</th>\n",
       "      <th>Recovered</th>\n",
       "      <th>Deaths</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <td>0</td>\n",
       "      <td>2020-01-22</td>\n",
       "      <td>Thailand</td>\n",
       "      <td>NaN</td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>1</td>\n",
       "      <td>2020-01-23</td>\n",
       "      <td>Thailand</td>\n",
       "      <td>NaN</td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>3</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>2</td>\n",
       "      <td>2020-01-24</td>\n",
       "      <td>Thailand</td>\n",
       "      <td>NaN</td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>5</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>3</td>\n",
       "      <td>2020-01-25</td>\n",
       "      <td>Thailand</td>\n",
       "      <td>NaN</td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>7</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>4</td>\n",
       "      <td>2020-01-26</td>\n",
       "      <td>Thailand</td>\n",
       "      <td>NaN</td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>8</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29702</td>\n",
       "      <td>2020-03-18</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td>NaN</td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29703</td>\n",
       "      <td>2020-03-19</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td>NaN</td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29704</td>\n",
       "      <td>2020-03-20</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td>NaN</td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29705</td>\n",
       "      <td>2020-03-21</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td>NaN</td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29706</td>\n",
       "      <td>2020-03-22</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td>NaN</td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>29707 rows Ã— 8 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "             Date Country/Region Province/State      Lat      Long  Confirmed  \\\n",
       "0      2020-01-22       Thailand            NaN  15.0000  101.0000          2   \n",
       "1      2020-01-23       Thailand            NaN  15.0000  101.0000          3   \n",
       "2      2020-01-24       Thailand            NaN  15.0000  101.0000          5   \n",
       "3      2020-01-25       Thailand            NaN  15.0000  101.0000          7   \n",
       "4      2020-01-26       Thailand            NaN  15.0000  101.0000          8   \n",
       "...           ...            ...            ...      ...       ...        ...   \n",
       "29702  2020-03-18    Timor-Leste            NaN  -8.8742  125.7275          0   \n",
       "29703  2020-03-19    Timor-Leste            NaN  -8.8742  125.7275          0   \n",
       "29704  2020-03-20    Timor-Leste            NaN  -8.8742  125.7275          0   \n",
       "29705  2020-03-21    Timor-Leste            NaN  -8.8742  125.7275          0   \n",
       "29706  2020-03-22    Timor-Leste            NaN  -8.8742  125.7275          1   \n",
       "\n",
       "       Recovered  Deaths  \n",
       "0              0       0  \n",
       "1              0       0  \n",
       "2              0       0  \n",
       "3              0       0  \n",
       "4              2       0  \n",
       "...          ...     ...  \n",
       "29702          0       0  \n",
       "29703          0       0  \n",
       "29704          0       0  \n",
       "29705          0       0  \n",
       "29706          0       0  \n",
       "\n",
       "[29707 rows x 8 columns]"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "COVID_DATA=\"Data/2020-03-22-time-series-19-covid-combined.csv\"\n",
    "data = pd.read_csv(COVID_DATA)\n",
    "data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Date               object\n",
       "Country/Region     object\n",
       "Province/State     object\n",
       "Lat               float64\n",
       "Long              float64\n",
       "Confirmed           int64\n",
       "Recovered           int64\n",
       "Deaths              int64\n",
       "dtype: object"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data.dtypes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The actual data type can vary within the same column:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<class 'str'>\n",
      "<class 'str'>\n",
      "<class 'float'>\n",
      "<class 'numpy.float64'>\n",
      "<class 'numpy.float64'>\n",
      "<class 'numpy.int64'>\n",
      "<class 'numpy.int64'>\n",
      "<class 'numpy.int64'>\n"
     ]
    }
   ],
   "source": [
    "for datum in data.iloc[0]:\n",
    "    print(type(datum))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Date</th>\n",
       "      <th>Country/Region</th>\n",
       "      <th>Province/State</th>\n",
       "      <th>Lat</th>\n",
       "      <th>Long</th>\n",
       "      <th>Confirmed</th>\n",
       "      <th>Recovered</th>\n",
       "      <th>Deaths</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <td>29034</td>\n",
       "      <td>2020-03-21</td>\n",
       "      <td>United Kingdom</td>\n",
       "      <td>Isle of Man</td>\n",
       "      <td>54.2361</td>\n",
       "      <td>-4.5481</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29035</td>\n",
       "      <td>2020-03-22</td>\n",
       "      <td>United Kingdom</td>\n",
       "      <td>Isle of Man</td>\n",
       "      <td>54.2361</td>\n",
       "      <td>-4.5481</td>\n",
       "      <td>5</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "             Date  Country/Region Province/State      Lat    Long  Confirmed  \\\n",
       "29034  2020-03-21  United Kingdom    Isle of Man  54.2361 -4.5481          1   \n",
       "29035  2020-03-22  United Kingdom    Isle of Man  54.2361 -4.5481          5   \n",
       "\n",
       "       Recovered  Deaths  \n",
       "29034          0       0  \n",
       "29035          0       0  "
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data.loc[data[\"Country/Region\"] == \"United Kingdom\"].tail(2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<class 'str'>\n",
      "<class 'str'>\n",
      "<class 'str'>\n",
      "<class 'numpy.float64'>\n",
      "<class 'numpy.float64'>\n",
      "<class 'numpy.int64'>\n",
      "<class 'numpy.int64'>\n",
      "<class 'numpy.int64'>\n"
     ]
    }
   ],
   "source": [
    "for datum in data.loc[data[\"Country/Region\"] == \"United Kingdom\"].iloc[0]:\n",
    "    print(type(datum))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> _Q: How successful has pandas been at inferring data types?_\n",
    "\n",
    "> _What types would you choose?_\n",
    "\n",
    "Lets try again. Starting with the province:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Date</th>\n",
       "      <th>Country/Region</th>\n",
       "      <th>Province/State</th>\n",
       "      <th>Lat</th>\n",
       "      <th>Long</th>\n",
       "      <th>Confirmed</th>\n",
       "      <th>Recovered</th>\n",
       "      <th>Deaths</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <td>0</td>\n",
       "      <td>2020-01-22</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>1</td>\n",
       "      <td>2020-01-23</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>3</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>2</td>\n",
       "      <td>2020-01-24</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>5</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>3</td>\n",
       "      <td>2020-01-25</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>7</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>4</td>\n",
       "      <td>2020-01-26</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0000</td>\n",
       "      <td>101.0000</td>\n",
       "      <td>8</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29702</td>\n",
       "      <td>2020-03-18</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td></td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29703</td>\n",
       "      <td>2020-03-19</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td></td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29704</td>\n",
       "      <td>2020-03-20</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td></td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29705</td>\n",
       "      <td>2020-03-21</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td></td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>29706</td>\n",
       "      <td>2020-03-22</td>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td></td>\n",
       "      <td>-8.8742</td>\n",
       "      <td>125.7275</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>29707 rows Ã— 8 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "             Date Country/Region Province/State      Lat      Long  Confirmed  \\\n",
       "0      2020-01-22       Thailand                 15.0000  101.0000          2   \n",
       "1      2020-01-23       Thailand                 15.0000  101.0000          3   \n",
       "2      2020-01-24       Thailand                 15.0000  101.0000          5   \n",
       "3      2020-01-25       Thailand                 15.0000  101.0000          7   \n",
       "4      2020-01-26       Thailand                 15.0000  101.0000          8   \n",
       "...           ...            ...            ...      ...       ...        ...   \n",
       "29702  2020-03-18    Timor-Leste                 -8.8742  125.7275          0   \n",
       "29703  2020-03-19    Timor-Leste                 -8.8742  125.7275          0   \n",
       "29704  2020-03-20    Timor-Leste                 -8.8742  125.7275          0   \n",
       "29705  2020-03-21    Timor-Leste                 -8.8742  125.7275          0   \n",
       "29706  2020-03-22    Timor-Leste                 -8.8742  125.7275          1   \n",
       "\n",
       "       Recovered  Deaths  \n",
       "0              0       0  \n",
       "1              0       0  \n",
       "2              0       0  \n",
       "3              0       0  \n",
       "4              2       0  \n",
       "...          ...     ...  \n",
       "29702          0       0  \n",
       "29703          0       0  \n",
       "29704          0       0  \n",
       "29705          0       0  \n",
       "29706          0       0  \n",
       "\n",
       "[29707 rows x 8 columns]"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data = pd.read_csv(COVID_DATA, na_filter=False)\n",
    "data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<class 'str'>\n",
      "<class 'str'>\n",
      "<class 'str'>\n",
      "<class 'numpy.float64'>\n",
      "<class 'numpy.float64'>\n",
      "<class 'numpy.int64'>\n",
      "<class 'numpy.int64'>\n",
      "<class 'numpy.int64'>\n"
     ]
    }
   ],
   "source": [
    "for datum in data.iloc[0]:\n",
    "    print(type(datum))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "What about the Date column?\n",
    "\n",
    "> _Q: Why is storing date and time information as strings not particularly useful?_\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Introducing time-series data\n",
    "\n",
    "The Date is provided in [ISO 801 format](https://www.iso.org/iso-8601-date-and-time-format.html). Why is this a good format to use?\n",
    "\n",
    "We could parse the Date string to get out the year, month and day ourselves, but we don't need to.\n",
    "\n",
    "Pandas is able to parse it, recognise the format, and convert it to its own (\"native\") timestamp format:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Date</th>\n",
       "      <th>Country/Region</th>\n",
       "      <th>Province/State</th>\n",
       "      <th>Lat</th>\n",
       "      <th>Long</th>\n",
       "      <th>Confirmed</th>\n",
       "      <th>Recovered</th>\n",
       "      <th>Deaths</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <td>0</td>\n",
       "      <td>2020-01-22</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0</td>\n",
       "      <td>101.0</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>1</td>\n",
       "      <td>2020-01-23</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0</td>\n",
       "      <td>101.0</td>\n",
       "      <td>3</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>2</td>\n",
       "      <td>2020-01-24</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0</td>\n",
       "      <td>101.0</td>\n",
       "      <td>5</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>3</td>\n",
       "      <td>2020-01-25</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0</td>\n",
       "      <td>101.0</td>\n",
       "      <td>7</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>4</td>\n",
       "      <td>2020-01-26</td>\n",
       "      <td>Thailand</td>\n",
       "      <td></td>\n",
       "      <td>15.0</td>\n",
       "      <td>101.0</td>\n",
       "      <td>8</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "        Date Country/Region Province/State   Lat   Long Confirmed Recovered  \\\n",
       "0 2020-01-22       Thailand                 15.0  101.0         2         0   \n",
       "1 2020-01-23       Thailand                 15.0  101.0         3         0   \n",
       "2 2020-01-24       Thailand                 15.0  101.0         5         0   \n",
       "3 2020-01-25       Thailand                 15.0  101.0         7         0   \n",
       "4 2020-01-26       Thailand                 15.0  101.0         8         2   \n",
       "\n",
       "  Deaths  \n",
       "0      0  \n",
       "1      0  \n",
       "2      0  \n",
       "3      0  \n",
       "4      0  "
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data = pd.read_csv(COVID_DATA, na_filter=False, parse_dates=[\"Date\"])\n",
    "data.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<class 'pandas._libs.tslibs.timestamps.Timestamp'>\n",
      "<class 'str'>\n",
      "<class 'str'>\n",
      "<class 'numpy.float64'>\n",
      "<class 'numpy.float64'>\n",
      "<class 'str'>\n",
      "<class 'str'>\n",
      "<class 'str'>\n"
     ]
    }
   ],
   "source": [
    "for datum in data.iloc[0]:\n",
    "    print(type(datum))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Timestamp('2020-01-22 00:00:00')"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data.at[0,\"Date\"]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets have a look at the documentation for pandas [Timestamp](https://pandas.pydata.org/pandas-docs/version/0.25.3/reference/api/pandas.Timestamp.html?highlight=timestamp) &rarr;\n",
    "\n",
    "Note that in the absence of a specific time, pandas has put in a default time. Why? Is there really any difference between data and time?\n",
    "\n",
    "There are many ways we can retrieve just the date information:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Timestamp('2020-03-26 12:06:52.605027')"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "now = pd.Timestamp.now()\n",
    "now"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "26 March 2020\n"
     ]
    }
   ],
   "source": [
    "print(now.day, now.month_name(), now.year)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "datetime.date(2020, 3, 26)"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "now.date()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `datetime` module provides many other facilities for viewing and manipulating dates and times."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Extracting the Australian data\n",
    "\n",
    "Let's start with some more practical column names:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "covid = pd.read_csv(COVID_DATA, na_filter=False, parse_dates=[\"Date\"])\n",
    "covid.rename(columns={\"Province/State\": \"State\", \"Country/Region\": \"Country\"}, \n",
    "             inplace=True)\n",
    "covid.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "auscovid = covid[covid[\"Country\"] == \"Australia\"]\n",
    "auscovid"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "auscovid.nlargest(1,\"Confirmed\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> _Q: How would we ask which state has the smallest count of confirmed cases?_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Exploration using Bar Plots"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "auscovid.loc[auscovid[\"State\"] == \"Western Australia\"].plot.bar(\"Date\",\"Confirmed\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "WA = auscovid.loc[(auscovid[\"State\"] == \"Western Australia\") & (auscovid[\"Confirmed\"]>0)]\n",
    "WA.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "WA.plot.bar(\"Date\",\"Confirmed\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The date labels are not very readable. Rather than create our own strings 'manually', we can use `strftime` (STRing Format TIME\"?)\n",
    "\n",
    "Some python documentation is not very useful! https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.strftime.html#pandas.Timestamp.strftime\n",
    "\n",
    "Although we haven't used the `datetime` module, pandas Timestamp is designed to be compatible with datetime, and we can [find some documentation there](https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can use pandas `apply` with a lambda function to format each date element:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "WA[\"Date\"].apply(lambda x: x.strftime(\"%B %d\")).head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ax = WA.plot.bar(\"Date\",\"Confirmed\")\n",
    "xlabels = WA[\"Date\"].apply(lambda x: x.strftime(\"%B %d\"))\n",
    "ax.set_xticklabels(xlabels)\n",
    "plt.ylabel(\"Number of cases\")\n",
    "plt.title(\"Western Australian Covid-19 Confirmed Cases\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We are also interested in the number of recoveries. We could plot those separately, but by plotting them together, we can get an idea of the _proportion_ of recoveries so far.\n",
    "\n",
    "Without arguments, Dataframe's plot function will try to plot all columns on the same graph:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ax = WA.plot.bar()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To overcome this problem, we'll create a temporary dataframe by filtering out just those (numerical) columns that we want:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "WA_totals = WA.filter([\"Confirmed\", \"Recovered\", \"Deaths\"])\n",
    "ax = WA_totals.plot.bar()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's try a different state with more data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "NSW = auscovid.loc[(auscovid[\"State\"] == \"New South Wales\") & (auscovid[\"Confirmed\"]>0)]\n",
    "NSW.tail(3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "NSW_totals = NSW.filter([\"Confirmed\", \"Recovered\", \"Deaths\"])\n",
    "ax = NSW_totals.plot.bar()\n",
    "xlabels = NSW[\"Date\"].apply(lambda x: x.strftime(\"%B %d\"))\n",
    "ax.set_xticklabels(xlabels)\n",
    "plt.ylabel(\"Number of cases\")\n",
    "plt.title(\"NSW Covid-19 Cases\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ax = NSW_totals.plot.bar(figsize=(10,2))\n",
    "ax.set_xticklabels(xlabels)\n",
    "plt.ylabel(\"Number of cases\")\n",
    "plt.title(\"NSW Covid-19 Cases\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It's getting too crowded to show by day. We could try showing by week.\n",
    "\n",
    "Let's use a list comprehension to get the day names and pick out the sundays:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "[x.day_name() for x in NSW[\"Date\"]][0:10]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "[x.day_name() == 'Sunday' for x in NSW[\"Date\"]][0:10]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "NSW_sundays = NSW.loc[[x.day_name() == 'Sunday' for x in NSW[\"Date\"]]]\n",
    "NSW_totals = NSW_sundays.filter([\"Confirmed\", \"Recovered\", \"Deaths\"])\n",
    "ax = NSW_totals.plot.bar(figsize=(6,4))\n",
    "ax.set_xticklabels(NSW_sundays[\"Date\"].apply(lambda x: x.strftime(\"%B %d\")))\n",
    "plt.ylabel(\"Number of cases\")\n",
    "plt.title(\"NSW Covid-19 Cases by Week\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We'd like to have a look at every state. Rather than \"manually\" coding for each state individually, we would like an efficient way to look at them all. \n",
    "\n",
    "Pandas provides a very useful class for just this kind of problem. It's called `GroupBy`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Using GroupBy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states = auscovid.groupby(\"State\")\n",
    "states.tail(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A little more data cleaning..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "auscovid = covid.loc[(covid[\"Country\"] == \"Australia\") & \n",
    "                     (covid[\"State\"] != \"From Diamond Princess\")]\n",
    "states = auscovid.groupby(\"State\")\n",
    "states.head(2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.max()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now very efficiently answer our earlier question!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.max()[\"Confirmed\"].idxmin()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.max().loc[states.max()[\"Confirmed\"].idxmin()]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But hang on. Is the State still a field (column) or not?\n",
    "\n",
    "This makes it look like it is:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.head(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But this suggests it's not - rather that it's an index:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.max()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Actually neither is quite right. Let's step back and have another look at GroupBy.\n",
    "\n",
    "GroupBy can be a little confusing. The `head` example looks like it might consist of a new Dataframe with the rows grouped. But lets have a look..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "type(states)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(states)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(WA)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "They are quite different. \n",
    "\n",
    "Methods like `head` and `max` create a _view_ on the GroupBy object. In many cases (including head and max) that view is returned as a dataframe."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "type(states.max())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So what's inside a GroupBy object? Perhaps the most revealing view is provided by the `groups` method which gives us a _dictionary_ view of the object:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.groups"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It maps keys to an [`Index` object](https://pandas.pydata.org/pandas-docs/version/0.25.3/reference/api/pandas.Int64Index.html#pandas.Int64Index) (specifically an `Int64Index`, but no need to remember that name).\n",
    "\n",
    "The states are the keys:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.groups.keys()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The Index in turn indexes the rows of the original dataframe."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "auscovid.loc[states.groups[\"Tasmania\"][0]]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But we rarely need to dig into that level of detail! Methods are provided to access the data in the most commonly used ways - typically as dataframes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.get_group(\"Tasmania\").head(1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So back to our question about the State as a column. We know it's stored in the GroupBy object as an key. Whenter it _appears_ as a column depends on whether the _method_ that creates the view includes it.\n",
    "\n",
    "In the case of `get_group`, it doesn't (by default)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.get_group(\"Tasmania\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This can be changed using the `as_index` attribute."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states2 = auscovid.groupby(\"State\", as_index=False)\n",
    "states2.get_group(\"Tasmania\").head(1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(Note that there appears to be a bug in the way GroupBy sets as_index and group_keys in the current version.)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Plotting all states"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now that we're familiar with GroupBy, let's use it to plot the data for all the states. \n",
    "\n",
    "As usual there are a number of ways we could do this. And as is often the case, one of the simplest and best is to use an iterator. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for name, group in states:\n",
    "    print(name)\n",
    "    print(group.head(2),\"\\n\")   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for name, group in states:\n",
    "    print(type(name))\n",
    "    print(type(group))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def weekly_barplot (statename, statedata):\n",
    "    state_sundays = statedata.loc[[x.day_name() == 'Sunday' for x in statedata[\"Date\"]]]\n",
    "    state_totals = state_sundays.filter([\"Confirmed\", \"Recovered\", \"Deaths\"])\n",
    "    ax = state_totals.plot.bar(figsize=(3,2))\n",
    "    ax.set_xticklabels(state_sundays[\"Date\"].apply(lambda x: x.strftime(\"%B %d\")))\n",
    "    plt.ylabel(\"Number of cases\")\n",
    "    plt.title(statename + \" Covid-19 Cases by Week\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for name, group in states:\n",
    "    weekly_barplot(name, group)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The ease of doing this shows the power of these data structures! \n",
    "\n",
    "However, it's a bit messy - we could make it cleaner using subplots.\n",
    "\n",
    "Also, its a bit visually misleading because the scales are different. ACT and NSW look kind of the same though they are vastly different in scale.\n",
    "\n",
    "We ought to make the y-axis consistent."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Using subplots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> _Q: If we're going to use an iterator (loop) to generate the plots in a subplot, where must the figure reside?_\n",
    "\n",
    ">_How will the loop know which subplot to use?_\n",
    "\n",
    ">_If we use a function for the 'repeated bits', what must be passed to the function?_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's do it in parts then we'll put it all together.\n",
    "\n",
    "We'll plot all states starting at the first confirmed Austrlian case."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "aus_first = auscovid[auscovid[\"Confirmed\"] > 0][\"Date\"].min()\n",
    "aus_first"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "aus_nz = auscovid[auscovid[\"Date\"] >= aus_first]\n",
    "aus_nz.head(3)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states = aus_nz.groupby(\"State\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Work out the size of the subplot, assuming two side by side in each row\n",
    "numstates = len(states.groups)\n",
    "numrows = int(round(np.ceil(numstates/2.0))) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Why do we use ceil?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set up reasonable sized subplots\n",
    "fig, axs = plt.subplots(numrows, 2, figsize=(8,4*numrows)) # length of figure depends on number of rows"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Iterate through the states, and pick out the right subplot\n",
    "position = 0\n",
    "for name, group in states:\n",
    "    print(np.divmod(position,2))\n",
    "    position = position + 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Iterate through the states, and pick out the right subplot\n",
    "fig, axs = plt.subplots(numrows, 2, figsize=(8,4*numrows)) # length of figure depends on number of rowsposition = 0\n",
    "position = 0\n",
    "for name, group in states:\n",
    "    (row, col) = np.divmod(position,2)\n",
    "    axs[row, col].set_title(name)\n",
    "    position = position + 1\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ðŸ‘\n",
    "\n",
    "Let's add some data..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Iterate through the states, and pick out the right subplot\n",
    "fig, axs = plt.subplots(numrows, 2, figsize=(8,4*numrows)) # length of figure depends on number of rowsposition = 0\n",
    "position = 0\n",
    "for statename, statedata in states:\n",
    "    (row, col) = np.divmod(position,2)\n",
    "    \n",
    "    state_sundays = statedata.loc[[x.day_name() == 'Sunday' for x in statedata[\"Date\"]]]\n",
    "\n",
    "    # Add each column to the plot \n",
    "    xs = np.arange(len(state_sundays))\n",
    "    width = 0.3\n",
    "    axs[row, col].bar(xs-width, state_sundays[\"Confirmed\"], width)\n",
    "    axs[row, col].bar(xs, state_sundays[\"Recovered\"], width)\n",
    "    axs[row, col].bar(xs+width, state_sundays[\"Deaths\"],width)\n",
    "    \n",
    "    axs[row, col].set_title(statename)\n",
    "    position = position + 1\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can deal with scale issue by sharing plotting on shared axes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Iterate through the states, and pick out the right subplot\n",
    "# Share axes to give common scale\n",
    "fig, axs = plt.subplots(numrows, 2, figsize=(8,4*numrows), sharex='all', sharey='all') # length of figure depends on number of rowsposition = 0\n",
    "position = 0\n",
    "for statename, statedata in states:\n",
    "    (row, col) = np.divmod(position,2)\n",
    "    \n",
    "    state_sundays = statedata.loc[[x.day_name() == 'Sunday' for x in statedata[\"Date\"]]]\n",
    "\n",
    "    # Add each column to the plot \n",
    "    xs = np.arange(len(state_sundays))\n",
    "    width = 0.3\n",
    "    axs[row, col].bar(xs-width, state_sundays[\"Confirmed\"], width)\n",
    "    axs[row, col].bar(xs, state_sundays[\"Recovered\"], width)\n",
    "    axs[row, col].bar(xs+width, state_sundays[\"Deaths\"],width)\n",
    "    \n",
    "    axs[row, col].set_title(statename)\n",
    "    position = position + 1\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Full code, with all the bells and whistles\n",
    "\n",
    "# Get data by state since first Australian occurrence\n",
    "aus_first = auscovid[auscovid[\"Confirmed\"] > 0][\"Date\"].min()\n",
    "aus_nz = auscovid[auscovid[\"Date\"] >= aus_first]\n",
    "states = aus_nz.groupby(\"State\")\n",
    "numstates = len(states.groups)\n",
    "numrows = int(round(np.ceil(numstates/2.0))) \n",
    "\n",
    "# Set up subplots and position 'pointer'\n",
    "fig, axs = plt.subplots(numrows, 2, figsize=(8,4*numrows), sharex='all', sharey='all') # length of figure depends on number of rowsposition = 0\n",
    "position = 0\n",
    "\n",
    "# Iterate through each state/plot\n",
    "for statename, statedata in states:\n",
    "    (row, col) = np.divmod(position,2)\n",
    "    position = position + 1\n",
    "    \n",
    "    # Extract sunday numbers\n",
    "    state_sundays = statedata.loc[[x.day_name() == 'Sunday' for x in statedata[\"Date\"]]]\n",
    "\n",
    "    # Add each column to the plot \n",
    "    xs = np.arange(len(state_sundays))\n",
    "    width = 0.3\n",
    "    axs[row, col].bar(xs-width, state_sundays[\"Confirmed\"], width, label=\"Confirmed\")\n",
    "    axs[row, col].bar(xs, state_sundays[\"Recovered\"], width, label=\"Recovered\")\n",
    "    axs[row, col].bar(xs+width, state_sundays[\"Deaths\"],width, label=\"Deaths\")\n",
    "    \n",
    "    # Label individual plot\n",
    "    axs[row, col].set_title(statename)\n",
    "    axs[row, col].legend(loc='upper left')\n",
    "    if row == numrows-1:\n",
    "        axs[row, col].set_xlabel(\"Days since first Australian case\")\n",
    "    if col == 0:\n",
    "        axs[row, col].set_ylabel(\"Number of cases\")\n",
    "\n",
    "# Set overall figure title and show figure\n",
    "fig.suptitle(\"Total Weekly Australian Covid-19 Cases by State\")\n",
    "fig.subplots_adjust(top=0.94) # cludge to get suptitle at the right height\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We've answered the first two questions. Let's use a function to make it cleaner.\n",
    "\n",
    "More importantly, notice that most of what is in the loop is independent of the specific country. _Can we make a function that will work for any country without writing it all again?_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def weekly_barsubplot (statename, statedata, axis):\n",
    "    sundays = statedata.loc[[x.day_name() == 'Sunday' for x in statedata[\"Date\"]]]\n",
    "    numbers = sundays.filter([\"Confirmed\", \"Recovered\", \"Deaths\"])\n",
    "    axis.bar(np.arange(len(sundays)), numbers)\n",
    "    axis.set_xticklabels(sundays[\"Date\"].apply(lambda x: x.strftime(\"%B %d\")))\n",
    "    plt.ylabel(\"Number of cases\")\n",
    "    plt.title(statename + \" Covid-19 Cases by Week\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Alternatively we can use `apply` to apply a function to the whole GroupBy object, one dataframe at a time.\n",
    "\n",
    "Unfortunately its a little messy:\n",
    "* We need the function to access the state name, but GroupBy by default strips this out and uses it as an index to the rest of the data.\n",
    "* Apply only applies to the remaining data.\n",
    "* You could be mistaken for thinking this is not the case, since some methods, like `head`, `max` above, print the index value as if it were the \"State\" field.\n",
    "* Note that `get_group`, however, does not!\n",
    "\n",
    "Yuck.\n",
    "\n",
    "However there is a fix. Setting `as_index` to false maintains the column (in an 'SQL-style' output). Counterintuitively it _does_ still use the column as the index ("
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def weekly_barplot2 (statedata):\n",
    "    print(statedata.index)\n",
    "#    state = statedata[\"State\"].iat[0]\n",
    "    sundays = statedata.loc[[x.day_name() == 'Sunday' for x in statedata[\"Date\"]]]\n",
    "    numbers = sundays.filter([\"Confirmed\", \"Recovered\", \"Deaths\"])\n",
    "    ax = numbers.plot.bar(figsize=(3,2))\n",
    "    ax.set_xticklabels(sundays[\"Date\"].apply(lambda x: x.strftime(\"%B %d\")))\n",
    "    plt.ylabel(\"Number of cases\")\n",
    "    plt.title(state + \" Covid-19 Cases by Week\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.apply(weekly_barplot2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "states.head(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Curve Fitting and Optimisation\n",
    "\n",
    "Are WA's infections really increasing exponentially? \n",
    "\n",
    "Don't believe the press! Let's find out for ourselves."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "WA.tail()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "len(WA)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(np.arange(len(WA)),WA[\"Confirmed\"])\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs = np.arange(len(WA))\n",
    "plt.plot(xs,WA[\"Confirmed\"])\n",
    "guesses = np.exp2(xs)\n",
    "plt.plot(xs, guesses)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(xs,WA[\"Confirmed\"])\n",
    "guesses = np.exp2(xs)/2000\n",
    "plt.plot(xs, guesses)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(xs,WA[\"Confirmed\"])\n",
    "guesses = np.exp2(xs/2)/10\n",
    "plt.plot(xs, guesses)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(xs,WA[\"Confirmed\"])\n",
    "guesses = 2 + np.exp2(xs/2)/10\n",
    "plt.plot(xs, guesses)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Pretty close!!\n",
    "\n",
    "But lets get the computer to do the work of finding the best match.\n",
    "\n",
    "First, we need to decide what form the function we want try and match to the data will take, and what _parameters_ we will vary.\n",
    "\n",
    "We'll define a function of the form `a + b * 2^(cx)`.\n",
    "As demonstrated above:\n",
    "* `a` \"shifts\" the function in the y direction\n",
    "* `b` \"scales\" (stretches or shrinks) the function\n",
    "* `c` determines the \"steepness\" of the function\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def my_exp (x, a, b, c):\n",
    "    return (a + b * np.exp2(x/c))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from scipy.optimize import curve_fit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "curve_fit(my_exp, xs, WA[\"Confirmed\"])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets capture the parameters. \n",
    "\n",
    "Remember our guesses were 2, 0.1, and 0.5. How did we compare?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "((a, b, c), covariance) = curve_fit(my_exp, xs, WA[\"Confirmed\"])\n",
    "(a, b, c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "((a, b, c), covariance) = curve_fit(my_exp, xs, WA[\"Confirmed\"])\n",
    "\n",
    "plt.plot(xs,WA[\"Confirmed\"])\n",
    "optimised_guesses = my_exp(xs, a, b, c)\n",
    "plt.plot(xs, optimised_guesses)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots()\n",
    "ax.plot(xs,WA[\"Confirmed\"])\n",
    "optimised_guesses = my_exp(xs, a, b, c)\n",
    "print(\"Parameters:\", a, b, c)\n",
    "ax.plot(xs, optimised_guesses)\n",
    "daynums = np.arange(0, len(xs), 2)\n",
    "ax.set_xticks(daynums)\n",
    "ax.set_xlabel(\"Days since first recorded infection in WA\")\n",
    "ax.set_ylabel(\"Number of confirmed infections\")\n",
    "ax.set_title(\"Are WA's Infections Really Increasing Exponentially?\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For interest, lets include all the data (the exponential function tends to zero as x tends to minus infinity, so we don't expect the fit to change much)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "WA_all = auscovid.loc[(auscovid[\"State\"] == \"Western Australia\")]\n",
    "WA_all.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs = np.arange(len(WA_all))\n",
    "((a, b, c), covariance) = curve_fit(my_exp, xs, WA_all[\"Confirmed\"])\n",
    "plt.plot(xs,WA_all[\"Confirmed\"])\n",
    "optimised_guesses = my_exp(xs, a, b, c)\n",
    "print(\"Parameters:\", a, b, c)\n",
    "plt.plot(xs, optimised_guesses)\n",
    "plt.xlabel(\"Days since records began\")\n",
    "plt.ylabel(\"Number of confirmed infections\")\n",
    "plt.title(\"Are WA's Infections Really Increasing Exponentially?\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs = np.arange(len(WA_all))\n",
    "cases = WA_all[\"Confirmed\"] < 1\n",
    "print(np.int8(cases))\n",
    "std = 10 * np.int8(cases) + 1\n",
    "init = [0, ]\n",
    "\n",
    "((a, b, c), covariance) = curve_fit(my_exp, xs, WA_all[\"Confirmed\"], sigma=std)\n",
    "plt.plot(xs,WA_all[\"Confirmed\"])\n",
    "optimised_guesses = my_exp(xs, a, b, c)\n",
    "print(\"Parameters:\", a, b, c)\n",
    "plt.plot(xs, optimised_guesses)\n",
    "plt.xlabel(\"Days since records began\")\n",
    "plt.ylabel(\"Number of confirmed infections\")\n",
    "plt.title(\"Are WA's Infections Really Increasing Exponentially?\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Which one are the press likely to use??"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notice that by starting at zero, the \"vertical shift\" of the first parameter is not really needed. \n",
    "\n",
    "Lets see if we can remove the first parameter and still get a good fit."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def my_zexp (x, b, c):\n",
    "    return (b * np.exp2(x/c))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "((b, c), covariance) = curve_fit(my_zexp, xs, WA_all[\"Confirmed\"])\n",
    "plt.plot(xs,WA_all[\"Confirmed\"])\n",
    "optimised_guesses = my_zexp(xs, b, c)\n",
    "print(\"Parameters:\", b, c)\n",
    "plt.plot(xs, optimised_guesses)\n",
    "plt.xlabel(\"Days since records began\")\n",
    "plt.ylabel(\"Number of confirmed infections\")\n",
    "plt.title(\"Are WA's Infections Really Increasing Exponentially?\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We also call these parameters _independent variables_ (we can set them independently of each other) and we call the number of independent variables the _degrees of freedom_.\n",
    "\n",
    "`my_exp` has 3 degrees of freedom, while `my_zexp` has only 2 degrees of freedom.\n",
    "\n",
    "Generally we like to use as _few degrees of freedom as we can_ to fit the data, so that we can understand the general trend of the data.\n",
    "\n",
    "Fitting a function with too many degrees of freedom often results in _over-fitting_, and describes the (random) variability in the data rather than the general trend.\n",
    "\n",
    "You will meet these concepts again in the __Statistical Learning__ unit!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## GroupBy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "combined = auscovid.groupby(\"Date\", as_index=False)\n",
    "aus_nz = auscovid[auscovid[\"Confirmed\"]>0]\n",
    "aus_combined_nz = aus_nz.groupby(\"Date\", as_index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "combined.sum().tail()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "combined.sum().plot.bar(\"Date\",\"Confirmed\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs = np.arange(len(combined))\n",
    "((b, c), covariance) = curve_fit(my_zexp, xs, combined.sum()[\"Confirmed\"])\n",
    "plt.plot(xs,combined.sum()[\"Confirmed\"], color='blue')\n",
    "optimised_guesses = my_zexp(xs, b, c)\n",
    "print(\"Parameters:\", b, c)\n",
    "plt.plot(xs, optimised_guesses, alpha=0.7, color='red')\n",
    "plt.xlabel(\"Days since records began\")\n",
    "plt.ylabel(\"Number of confirmed infections\")\n",
    "plt.title(\"Are Australia's Infections Really Increasing Exponentially?\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs = np.arange(len(aus_combined_nz))\n",
    "((b, c), covariance) = curve_fit(my_zexp, xs, aus_combined_nz.sum()[\"Confirmed\"])\n",
    "plt.plot(xs,aus_combined_nz.sum()[\"Confirmed\"], color='blue')\n",
    "optimised_guesses = my_zexp(xs, b, c)\n",
    "print(\"Parameters:\", b, c)\n",
    "plt.plot(xs, optimised_guesses, alpha=0.7, color='red')\n",
    "plt.xlabel(\"Days since first recorded case\")\n",
    "plt.ylabel(\"Number of confirmed infections\")\n",
    "plt.title(\"Are Australia's Infections Really Increasing Exponentially?\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Country Comparisons"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def my_exp2 (x, a, b):\n",
    "    return (np.exp2(a*x + b))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def country_plot (country, status=\"Confirmed\", fit_exp=False, limit = np.inf):\n",
    "    country_data = covid[covid[\"Country\"] == country]\n",
    "    if not country_data[\"State\"].isin([\"\"]).all():\n",
    "        print(\"Warning: country data could be divided over regions\")\n",
    "    country_nonzero = country_data[(country_data[status] > 0) & (country_data[status] < limit)]\n",
    "#    print(country_nonzero.max())\n",
    "    xs = np.arange(len(country_nonzero))\n",
    "    plt.plot(xs,country_nonzero[status], color='blue')\n",
    "\n",
    "    if fit_exp:\n",
    "        ((b, c), covariance) = curve_fit(my_exp2, xs, country_nonzero[status])\n",
    "        optimised_guesses = my_exp2(xs, b, c)\n",
    "        print(\"Parameters:\", b, c)\n",
    "        plt.plot(xs, optimised_guesses, alpha=0.7, color='red')\n",
    "\n",
    "    plt.xlabel(\"Days since first recorded case\")\n",
    "    plt.ylabel(\"Number \"+status)\n",
    "    plt.title(country)\n",
    "    plt.show()\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def country_plot2 (country, statuses=[\"Confirmed\",\"Deaths\"], fit_exp=False, limit = np.inf):\n",
    "    country_data = covid[covid[\"Country\"] == country]\n",
    "    country_combined = country_data.groupby(\"Date\").sum()\n",
    "    country_nonzero = country_combined[(country_combined[\"Confirmed\"] > 0) & \n",
    "                                       (country_combined[\"Confirmed\"] < limit)]\n",
    "\n",
    "    xs = np.arange(len(country_nonzero))\n",
    "    for status in statuses:\n",
    "        plt.plot(xs,country_nonzero[status])\n",
    "\n",
    "        if fit_exp:\n",
    "            ((b, c), covariance) = curve_fit(my_exp2, xs, country_nonzero[status])\n",
    "            optimised_guesses = my_exp2(xs, b, c)\n",
    "            print(\"Parameters:\", b, c)\n",
    "            plt.plot(xs, optimised_guesses, alpha=0.7, color='gray')\n",
    "\n",
    "    plt.xlabel(\"Days since first recorded case\")\n",
    "    plt.ylabel(\"Number \"+status)\n",
    "    plt.title(country)\n",
    "    plt.show()\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Italy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "italy_covid = covid[covid[\"Country\"] == \"Italy\"]\n",
    "italy_covid.tail()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "country_plot2(\"Italy\", statuses=[\"Confirmed\",\"Deaths\"], fit_exp=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "country_plot2(\"Australia\", fit_exp=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "country_plot2(\"France\", fit_exp=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "country_plot2(\"China\", fit_exp=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "covid[covid[\"Country\"].between(\"Ko\", \"Kp\")]\n",
    "country_plot2(\"Korea, South\", fit_exp=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "italy_comparative = italycovid[(italycovid[\"Confirmed\"]<1500) & (italycovid[\"Confirmed\"]>0)]\n",
    "italy_comparative.tail()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(np.arange(len(italy_comparative)),italy_comparative[\"Confirmed\"])\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs = np.arange(len(italy_comparative))\n",
    "((b, c), covariance) = curve_fit(my_zexp, xs, italy_nz[\"Confirmed\"])\n",
    "plt.plot(xs,italy_nz[\"Confirmed\"], color='blue')\n",
    "optimised_guesses = my_zexp(xs, b, c)\n",
    "print(\"Parameters:\", b, c)\n",
    "plt.plot(xs, optimised_guesses, alpha=0.7, color='red')\n",
    "plt.xlabel(\"Days since first recorded case\")\n",
    "plt.ylabel(\"Number of confirmed infections\")\n",
    "plt.title(\"Italy\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs = np.arange(len(italycovid))\n",
    "plt.plot(xs,italycovid[\"Confirmed\"], color='blue')\n",
    "#((b, c), covariance) = curve_fit(my_zexp, xs, italy_nz[\"Confirmed\"])\n",
    "#optimised_guesses = my_zexp(xs, b, c)\n",
    "#print(\"Parameters:\", b, c)\n",
    "#plt.plot(xs, optimised_guesses, alpha=0.7, color='red')\n",
    "plt.xlabel(\"Days since first recorded case\")\n",
    "plt.ylabel(\"Number of confirmed infections\")\n",
    "plt.title(\"Italy\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Spain"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "overall_plot(\"Spain\", fitexp=True, limit=1600)\n",
    "overall_plot(\"Italy\", fitexp=True, limit=1400)\n",
    "overall_plot(\"Singapore\")\n",
    "overall_plot(\"South Korea\")\n",
    "overall_plot(\"China\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "spain_covid = covid[covid[\"Country\"] == \"Spain\"]\n",
    "spain_covid.tail(20)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "france_covid = covid.loc[covid[\"Country\"] == \"France\"]\n",
    "france_covid.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "france_covid[\"State\"].isin([\"\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "spain_covid = covid.loc[covid[\"Country\"] == \"Spain\"]\n",
    "spain_covid.tail()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs = np.arange(len(spain_covid))\n",
    "plt.plot(xs,italycovid[\"Confirmed\"], color='blue')\n",
    "#((b, c), covariance) = curve_fit(my_zexp, xs, italy_nz[\"Confirmed\"])\n",
    "#optimised_guesses = my_zexp(xs, b, c)\n",
    "#print(\"Parameters:\", b, c)\n",
    "#plt.plot(xs, optimised_guesses, alpha=0.7, color='red')\n",
    "plt.xlabel(\"Days since first recorded case\")\n",
    "plt.ylabel(\"Number of confirmed infections\")\n",
    "plt.title(\"Italy\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "italy_nz.plot.bar([\"Confirmed\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "with open(\"datapackage.json\",'r') as file:\n",
    "    di = json.load(file)\n",
    "di"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "data = pd.read_csv(\"time-series-19-covid-combined.csv\", converters=di)\n",
    "data\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for datum in data.iloc[1]:\n",
    "    print(type(datum))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import datapackage\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "j = pd.read_json(\"datapackage.json\")\n",
    "j.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "mytypes = {\"Province/State\": str, \"Country/Region\": str,\n",
    "           \"Lat\": np.float64, \"Long\": np.float64,\n",
    "           \"Date\": str, \n",
    "           \"Confirmed\": np.int64, \"Recovered\": np.int64, \"Deaths\": np.int64}\n",
    "data = pd.read_csv(\"time-series-19-covid-combined.csv\", dtype=mytypes, na_filter=False)\n",
    "data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for datum in data.iloc[1]:\n",
    "    print(type(datum))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "type(data[\"Date\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "data[\"Date\"].dtypes\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "data.infer_objects()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
